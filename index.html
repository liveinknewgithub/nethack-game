<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EmojiHack - A NetHack Clone</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="A free browser-based roguelike adventure inspired by NetHack. Explore procedural dungeons, fight monsters, collect loot, and defeat the dragon - all with emojis!">
    <meta name="keywords" content="roguelike, nethack, game, browser game, emoji, dungeon crawler, free game">
    <meta name="author" content="EmojiHack">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://liveinknewgithub.github.io/nethack-game/">
    <meta property="og:title" content="EmojiHack - A NetHack-Inspired Roguelike Adventure">
    <meta property="og:description" content="Explore procedural dungeons, fight monsters, collect loot, and defeat the dragon - all with emojis! Free to play in your browser.">
    <meta property="og:image" content="https://liveinknewgithub.github.io/nethack-game/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://liveinknewgithub.github.io/nethack-game/">
    <meta name="twitter:title" content="EmojiHack - A NetHack-Inspired Roguelike Adventure">
    <meta name="twitter:description" content="Explore procedural dungeons, fight monsters, collect loot, and defeat the dragon - all with emojis! Free to play in your browser.">
    <meta name="twitter:image" content="https://liveinknewgithub.github.io/nethack-game/og-image.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        #game-container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
        }
        #main-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #game-canvas {
            border: 3px solid #4a4a6a;
            border-radius: 8px;
            background: #0a0a1a;
        }
        #message-log {
            background: #0a0a1a;
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            padding: 10px;
            height: 120px;
            overflow-y: auto;
            font-size: 14px;
        }
        .message {
            padding: 2px 0;
            border-bottom: 1px solid #2a2a4a;
        }
        .message:last-child {
            border-bottom: none;
        }
        .msg-combat { color: #ff6b6b; }
        .msg-item { color: #4ecdc4; }
        .msg-info { color: #ffe66d; }
        .msg-level { color: #a855f7; }
        #side-panel {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .panel-section {
            background: #0a0a1a;
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            padding: 15px;
        }
        .panel-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffe66d;
            border-bottom: 1px solid #4a4a6a;
            padding-bottom: 5px;
        }
        #stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .hp-bar-container {
            width: 100%;
            height: 20px;
            background: #2a2a4a;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        .hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ee5a5a);
            transition: width 0.3s;
        }
        #inventory-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        .inv-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            background: #1a1a2e;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .inv-item:hover {
            background: #2a2a4e;
        }
        .inv-item.equipped {
            border: 1px solid #4ecdc4;
        }
        .inv-key {
            background: #4a4a6a;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        #controls {
            font-size: 13px;
            line-height: 1.6;
        }
        #controls kbd {
            background: #4a4a6a;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
        }
        #game-over-screen, #win-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
        }
        #game-over-screen h1 {
            font-size: 48px;
            color: #ff6b6b;
        }
        #win-screen h1 {
            font-size: 48px;
            color: #4ecdc4;
        }
        .restart-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: #4a4a6a;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .restart-btn:hover {
            background: #6a6a8a;
        }
        #title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 30px;
            z-index: 100;
        }
        #title-screen h1 {
            font-size: 64px;
        }
        #title-screen p {
            font-size: 18px;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="title-screen">
        <h1>üßô EmojiHack üêâ</h1>
        <p>A NetHack-inspired roguelike adventure</p>
        <button class="restart-btn" onclick="startGame()">Start Game</button>
        <div style="text-align: center; color: #666; font-size: 14px;">
            <p>WASD or Arrow Keys to move</p>
            <p>Bump into enemies to attack</p>
            <p>Reach Level 5 and find the Dragon!</p>
        </div>
    </div>

    <div id="game-over-screen">
        <h1>üíÄ You Died üíÄ</h1>
        <p id="death-message">You were slain by a monster...</p>
        <button class="restart-btn" onclick="restartGame()">Try Again</button>
    </div>

    <div id="win-screen">
        <h1>üèÜ Victory! üèÜ</h1>
        <p>You defeated the Dragon and saved the realm!</p>
        <p id="win-stats"></p>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>

    <div id="game-container">
        <div id="main-panel">
            <canvas id="game-canvas" width="800" height="600"></canvas>
            <div id="message-log"></div>
        </div>
        <div id="side-panel">
            <div class="panel-section">
                <div class="panel-title">üßô Hero</div>
                <div id="stats">
                    <div class="stat-row">
                        <span>Level:</span>
                        <span id="player-level">1</span>
                    </div>
                    <div class="stat-row">
                        <span>Dungeon:</span>
                        <span id="dungeon-level">1</span>
                    </div>
                    <div class="stat-row">
                        <span>Gold:</span>
                        <span id="gold">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Attack:</span>
                        <span id="attack">5</span>
                    </div>
                    <div class="stat-row">
                        <span>Defense:</span>
                        <span id="defense">0</span>
                    </div>
                    <div>
                        <span>HP: <span id="hp">20</span>/<span id="max-hp">20</span></span>
                        <div class="hp-bar-container">
                            <div class="hp-bar" id="hp-bar"></div>
                        </div>
                    </div>
                    <div class="stat-row">
                        <span>XP:</span>
                        <span id="xp">0</span>/<span id="xp-next">10</span>
                    </div>
                </div>
            </div>
            <div class="panel-section">
                <div class="panel-title">üéí Inventory</div>
                <div id="inventory-list"></div>
            </div>
            <div class="panel-section">
                <div class="panel-title">üìú Controls</div>
                <div id="controls">
                    <kbd>WASD</kbd> / <kbd>‚Üë‚Üì‚Üê‚Üí</kbd> Move<br>
                    <kbd>G</kbd> Pick up item<br>
                    <kbd>1</kbd>-<kbd>9</kbd> Use item<br>
                    <kbd>&gt;</kbd> Descend stairs<br>
                    <kbd>&lt;</kbd> Ascend stairs
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // EMOJIHACK - A NetHack Clone with Emojis
        // ============================================

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Tile size for rendering
        const TILE_SIZE = 24;
        const MAP_WIDTH = 32;
        const MAP_HEIGHT = 24;
        const MAX_DUNGEON_LEVEL = 5;

        // Tile types
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            DOOR: 2,
            STAIRS_DOWN: 3,
            STAIRS_UP: 4
        };

        // Emoji mappings
        const EMOJI = {
            PLAYER: 'üßô',
            FLOOR: '‚¨õ',
            WALL: 'üß±',
            DOOR: 'üö™',
            STAIRS_DOWN: 'üï≥Ô∏è',
            STAIRS_UP: 'ü™ú',
            UNEXPLORED: '‚¨ú',
            GOLD: 'üí∞',
            POTION: 'üß™',
            SWORD: '‚öîÔ∏è',
            SHIELD: 'üõ°Ô∏è',
            FOOD: 'üçñ',
            RAT: 'üêÄ',
            SNAKE: 'üêç',
            GOBLIN: 'üë∫',
            SKELETON: 'üíÄ',
            DRAGON: 'üêâ'
        };

        // Item definitions
        const ITEM_TYPES = {
            GOLD: { emoji: 'üí∞', name: 'Gold', type: 'gold', value: 10 },
            POTION: { emoji: 'üß™', name: 'Health Potion', type: 'consumable', heal: 15 },
            SWORD: { emoji: '‚öîÔ∏è', name: 'Sword', type: 'weapon', attack: 3 },
            SHIELD: { emoji: 'üõ°Ô∏è', name: 'Shield', type: 'armor', defense: 2 },
            FOOD: { emoji: 'üçñ', name: 'Food', type: 'consumable', heal: 8 },
            SWORD_PLUS: { emoji: '‚öîÔ∏è', name: 'Fine Sword', type: 'weapon', attack: 5 },
            SHIELD_PLUS: { emoji: 'üõ°Ô∏è', name: 'Steel Shield', type: 'armor', defense: 4 },
            SUPER_POTION: { emoji: 'üß™', name: 'Super Potion', type: 'consumable', heal: 30 }
        };

        // Enemy definitions
        const ENEMY_TYPES = {
            RAT: { emoji: 'üêÄ', name: 'Rat', hp: 5, attack: 2, defense: 0, xp: 3 },
            SNAKE: { emoji: 'üêç', name: 'Snake', hp: 8, attack: 4, defense: 1, xp: 5 },
            GOBLIN: { emoji: 'üë∫', name: 'Goblin', hp: 12, attack: 5, defense: 2, xp: 8 },
            SKELETON: { emoji: 'üíÄ', name: 'Skeleton', hp: 18, attack: 7, defense: 3, xp: 12 },
            DRAGON: { emoji: 'üêâ', name: 'Dragon', hp: 50, attack: 12, defense: 5, xp: 100, boss: true }
        };

        // Game state
        let game = {
            map: [],
            explored: [],
            visible: [],
            player: null,
            enemies: [],
            items: [],
            dungeonLevel: 1,
            messages: [],
            gameOver: false,
            won: false
        };

        // Player object
        function createPlayer() {
            return {
                x: 0,
                y: 0,
                hp: 20,
                maxHp: 20,
                attack: 5,
                defense: 0,
                level: 1,
                xp: 0,
                xpToLevel: 10,
                gold: 0,
                inventory: [],
                weapon: null,
                armor: null
            };
        }

        // ============================================
        // DUNGEON GENERATION
        // ============================================

        function generateDungeon() {
            // Initialize map with walls
            game.map = [];
            game.explored = [];
            game.visible = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                game.map[y] = [];
                game.explored[y] = [];
                game.visible[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    game.map[y][x] = TILES.WALL;
                    game.explored[y][x] = false;
                    game.visible[y][x] = false;
                }
            }

            // Generate rooms
            const rooms = [];
            const numRooms = 6 + Math.floor(Math.random() * 4);

            for (let i = 0; i < numRooms * 10 && rooms.length < numRooms; i++) {
                const w = 4 + Math.floor(Math.random() * 6);
                const h = 3 + Math.floor(Math.random() * 4);
                const x = 1 + Math.floor(Math.random() * (MAP_WIDTH - w - 2));
                const y = 1 + Math.floor(Math.random() * (MAP_HEIGHT - h - 2));

                const room = { x, y, w, h, cx: Math.floor(x + w/2), cy: Math.floor(y + h/2) };

                // Check overlap
                let overlaps = false;
                for (const other of rooms) {
                    if (x < other.x + other.w + 1 && x + w + 1 > other.x &&
                        y < other.y + other.h + 1 && y + h + 1 > other.y) {
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    rooms.push(room);
                    // Carve room
                    for (let ry = y; ry < y + h; ry++) {
                        for (let rx = x; rx < x + w; rx++) {
                            game.map[ry][rx] = TILES.FLOOR;
                        }
                    }
                }
            }

            // Connect rooms with corridors
            for (let i = 1; i < rooms.length; i++) {
                const prev = rooms[i - 1];
                const curr = rooms[i];

                // Horizontal then vertical
                if (Math.random() < 0.5) {
                    carveHCorridor(prev.cx, curr.cx, prev.cy);
                    carveVCorridor(prev.cy, curr.cy, curr.cx);
                } else {
                    carveVCorridor(prev.cy, curr.cy, prev.cx);
                    carveHCorridor(prev.cx, curr.cx, curr.cy);
                }
            }

            // Place stairs
            const firstRoom = rooms[0];
            const lastRoom = rooms[rooms.length - 1];

            if (game.dungeonLevel > 1) {
                game.map[firstRoom.cy][firstRoom.cx] = TILES.STAIRS_UP;
            }

            if (game.dungeonLevel < MAX_DUNGEON_LEVEL) {
                game.map[lastRoom.cy][lastRoom.cx] = TILES.STAIRS_DOWN;
            }

            // Place player
            game.player.x = firstRoom.cx;
            game.player.y = firstRoom.cy;
            if (game.map[firstRoom.cy][firstRoom.cx] === TILES.STAIRS_UP) {
                // Find adjacent floor
                const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
                for (const [dx, dy] of dirs) {
                    if (game.map[firstRoom.cy + dy][firstRoom.cx + dx] === TILES.FLOOR) {
                        game.player.x = firstRoom.cx + dx;
                        game.player.y = firstRoom.cy + dy;
                        break;
                    }
                }
            }

            // Spawn enemies
            game.enemies = [];
            const numEnemies = 3 + game.dungeonLevel * 2;
            const enemyPool = getEnemyPool();

            for (let i = 0; i < numEnemies; i++) {
                const room = rooms[1 + Math.floor(Math.random() * (rooms.length - 1))];
                const ex = room.x + 1 + Math.floor(Math.random() * (room.w - 2));
                const ey = room.y + 1 + Math.floor(Math.random() * (room.h - 2));

                if (game.map[ey][ex] === TILES.FLOOR &&
                    !(ex === game.player.x && ey === game.player.y)) {
                    const type = enemyPool[Math.floor(Math.random() * enemyPool.length)];
                    game.enemies.push({
                        ...ENEMY_TYPES[type],
                        x: ex,
                        y: ey,
                        maxHp: ENEMY_TYPES[type].hp
                    });
                }
            }

            // Spawn dragon on last level
            if (game.dungeonLevel === MAX_DUNGEON_LEVEL) {
                const room = lastRoom;
                game.enemies.push({
                    ...ENEMY_TYPES.DRAGON,
                    x: room.cx,
                    y: room.cy,
                    maxHp: ENEMY_TYPES.DRAGON.hp
                });
            }

            // Spawn items
            game.items = [];
            const numItems = 4 + game.dungeonLevel;
            const itemPool = getItemPool();

            for (let i = 0; i < numItems; i++) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                const ix = room.x + 1 + Math.floor(Math.random() * (room.w - 2));
                const iy = room.y + 1 + Math.floor(Math.random() * (room.h - 2));

                if (game.map[iy][ix] === TILES.FLOOR) {
                    const typeKey = itemPool[Math.floor(Math.random() * itemPool.length)];
                    game.items.push({
                        ...ITEM_TYPES[typeKey],
                        x: ix,
                        y: iy
                    });
                }
            }

            updateVisibility();
        }

        function getEnemyPool() {
            const pools = {
                1: ['RAT', 'RAT', 'SNAKE'],
                2: ['RAT', 'SNAKE', 'SNAKE', 'GOBLIN'],
                3: ['SNAKE', 'GOBLIN', 'GOBLIN', 'SKELETON'],
                4: ['GOBLIN', 'SKELETON', 'SKELETON'],
                5: ['SKELETON', 'SKELETON', 'GOBLIN']
            };
            return pools[game.dungeonLevel] || pools[5];
        }

        function getItemPool() {
            if (game.dungeonLevel <= 2) {
                return ['GOLD', 'GOLD', 'POTION', 'FOOD', 'SWORD', 'SHIELD'];
            } else {
                return ['GOLD', 'POTION', 'SUPER_POTION', 'FOOD', 'SWORD_PLUS', 'SHIELD_PLUS'];
            }
        }

        function carveHCorridor(x1, x2, y) {
            const start = Math.min(x1, x2);
            const end = Math.max(x1, x2);
            for (let x = start; x <= end; x++) {
                if (y > 0 && y < MAP_HEIGHT - 1 && x > 0 && x < MAP_WIDTH - 1) {
                    game.map[y][x] = TILES.FLOOR;
                }
            }
        }

        function carveVCorridor(y1, y2, x) {
            const start = Math.min(y1, y2);
            const end = Math.max(y1, y2);
            for (let y = start; y <= end; y++) {
                if (y > 0 && y < MAP_HEIGHT - 1 && x > 0 && x < MAP_WIDTH - 1) {
                    game.map[y][x] = TILES.FLOOR;
                }
            }
        }

        // ============================================
        // VISIBILITY / FOG OF WAR
        // ============================================

        function updateVisibility() {
            const VISION_RADIUS = 6;

            // Reset visibility
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    game.visible[y][x] = false;
                }
            }

            // Simple raycasting for visibility
            for (let angle = 0; angle < 360; angle += 2) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);

                for (let dist = 0; dist <= VISION_RADIUS; dist += 0.5) {
                    const x = Math.round(game.player.x + dx * dist);
                    const y = Math.round(game.player.y + dy * dist);

                    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) break;

                    game.visible[y][x] = true;
                    game.explored[y][x] = true;

                    if (game.map[y][x] === TILES.WALL) break;
                }
            }
        }

        // ============================================
        // RENDERING
        // ============================================

        function render() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = `${TILE_SIZE - 2}px 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Calculate offset to center map
            const offsetX = (canvas.width - MAP_WIDTH * TILE_SIZE) / 2;
            const offsetY = (canvas.height - MAP_HEIGHT * TILE_SIZE) / 2;

            // Draw tiles
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const px = offsetX + x * TILE_SIZE + TILE_SIZE / 2;
                    const py = offsetY + y * TILE_SIZE + TILE_SIZE / 2;

                    if (!game.explored[y][x]) {
                        ctx.globalAlpha = 1;
                        ctx.fillText(EMOJI.UNEXPLORED, px, py);
                    } else if (!game.visible[y][x]) {
                        ctx.globalAlpha = 0.4;
                        ctx.fillText(getTileEmoji(x, y), px, py);
                    } else {
                        ctx.globalAlpha = 1;
                        ctx.fillText(getTileEmoji(x, y), px, py);
                    }
                }
            }

            ctx.globalAlpha = 1;

            // Draw items (only if visible)
            for (const item of game.items) {
                if (game.visible[item.y][item.x]) {
                    const px = offsetX + item.x * TILE_SIZE + TILE_SIZE / 2;
                    const py = offsetY + item.y * TILE_SIZE + TILE_SIZE / 2;
                    ctx.fillText(item.emoji, px, py);
                }
            }

            // Draw enemies (only if visible)
            for (const enemy of game.enemies) {
                if (game.visible[enemy.y][enemy.x]) {
                    const px = offsetX + enemy.x * TILE_SIZE + TILE_SIZE / 2;
                    const py = offsetY + enemy.y * TILE_SIZE + TILE_SIZE / 2;
                    ctx.fillText(enemy.emoji, px, py);

                    // Draw HP bar for enemies
                    const barWidth = TILE_SIZE - 4;
                    const barHeight = 3;
                    const barX = offsetX + enemy.x * TILE_SIZE + 2;
                    const barY = offsetY + enemy.y * TILE_SIZE - 2;
                    const hpPercent = enemy.hp / enemy.maxHp;

                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = hpPercent > 0.5 ? '#4ecdc4' : hpPercent > 0.25 ? '#ffe66d' : '#ff6b6b';
                    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                }
            }

            // Draw player
            const playerPx = offsetX + game.player.x * TILE_SIZE + TILE_SIZE / 2;
            const playerPy = offsetY + game.player.y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillText(EMOJI.PLAYER, playerPx, playerPy);

            // Update UI
            updateUI();
        }

        function getTileEmoji(x, y) {
            switch (game.map[y][x]) {
                case TILES.FLOOR: return EMOJI.FLOOR;
                case TILES.WALL: return EMOJI.WALL;
                case TILES.DOOR: return EMOJI.DOOR;
                case TILES.STAIRS_DOWN: return EMOJI.STAIRS_DOWN;
                case TILES.STAIRS_UP: return EMOJI.STAIRS_UP;
                default: return EMOJI.FLOOR;
            }
        }

        function updateUI() {
            document.getElementById('player-level').textContent = game.player.level;
            document.getElementById('dungeon-level').textContent = game.dungeonLevel;
            document.getElementById('gold').textContent = game.player.gold;
            document.getElementById('hp').textContent = game.player.hp;
            document.getElementById('max-hp').textContent = game.player.maxHp;
            document.getElementById('xp').textContent = game.player.xp;
            document.getElementById('xp-next').textContent = game.player.xpToLevel;

            const totalAttack = game.player.attack + (game.player.weapon ? game.player.weapon.attack : 0);
            const totalDefense = game.player.defense + (game.player.armor ? game.player.armor.defense : 0);
            document.getElementById('attack').textContent = totalAttack;
            document.getElementById('defense').textContent = totalDefense;

            const hpPercent = (game.player.hp / game.player.maxHp) * 100;
            document.getElementById('hp-bar').style.width = hpPercent + '%';

            // Update inventory
            const invList = document.getElementById('inventory-list');
            invList.innerHTML = '';
            game.player.inventory.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'inv-item';
                if (item === game.player.weapon || item === game.player.armor) {
                    div.classList.add('equipped');
                }
                div.innerHTML = `<span class="inv-key">${index + 1}</span> ${item.emoji} ${item.name}`;
                div.onclick = () => useItem(index);
                invList.appendChild(div);
            });
        }

        function addMessage(text, type = 'info') {
            game.messages.unshift({ text, type });
            if (game.messages.length > 50) game.messages.pop();

            const log = document.getElementById('message-log');
            const div = document.createElement('div');
            div.className = `message msg-${type}`;
            div.textContent = text;
            log.insertBefore(div, log.firstChild);

            // Keep only last 20 messages in DOM
            while (log.children.length > 20) {
                log.removeChild(log.lastChild);
            }
        }

        // ============================================
        // PLAYER ACTIONS
        // ============================================

        function movePlayer(dx, dy) {
            if (game.gameOver || game.won) return;

            const newX = game.player.x + dx;
            const newY = game.player.y + dy;

            // Bounds check
            if (newX < 0 || newX >= MAP_WIDTH || newY < 0 || newY >= MAP_HEIGHT) return;

            // Wall check
            if (game.map[newY][newX] === TILES.WALL) return;

            // Enemy check (combat)
            const enemy = game.enemies.find(e => e.x === newX && e.y === newY);
            if (enemy) {
                attackEnemy(enemy);
                enemyTurn();
                render();
                return;
            }

            // Move player
            game.player.x = newX;
            game.player.y = newY;

            // Auto-pickup gold
            const goldItem = game.items.find(i => i.x === newX && i.y === newY && i.type === 'gold');
            if (goldItem) {
                game.player.gold += goldItem.value;
                game.items = game.items.filter(i => i !== goldItem);
                addMessage(`Picked up ${goldItem.value} gold!`, 'item');
            }

            updateVisibility();
            enemyTurn();
            render();
        }

        function attackEnemy(enemy) {
            const playerAttack = game.player.attack + (game.player.weapon ? game.player.weapon.attack : 0);
            const damage = Math.max(1, playerAttack - enemy.defense + Math.floor(Math.random() * 3));

            enemy.hp -= damage;
            addMessage(`You hit the ${enemy.name} for ${damage} damage!`, 'combat');

            if (enemy.hp <= 0) {
                game.enemies = game.enemies.filter(e => e !== enemy);
                addMessage(`You defeated the ${enemy.name}!`, 'combat');
                gainXP(enemy.xp);

                // Check for dragon kill (win condition)
                if (enemy.boss) {
                    game.won = true;
                    document.getElementById('win-stats').textContent =
                        `Level ${game.player.level} | ${game.player.gold} Gold | Dungeon ${game.dungeonLevel}`;
                    document.getElementById('win-screen').style.display = 'flex';
                }
            }
        }

        function gainXP(amount) {
            game.player.xp += amount;
            while (game.player.xp >= game.player.xpToLevel) {
                game.player.xp -= game.player.xpToLevel;
                game.player.level++;
                game.player.xpToLevel = Math.floor(game.player.xpToLevel * 1.5);
                game.player.maxHp += 5;
                game.player.hp = game.player.maxHp;
                game.player.attack += 1;
                addMessage(`Level up! You are now level ${game.player.level}!`, 'level');
            }
        }

        function pickupItem() {
            const item = game.items.find(i => i.x === game.player.x && i.y === game.player.y);
            if (!item) {
                addMessage('Nothing to pick up here.', 'info');
                return;
            }

            if (item.type === 'gold') {
                game.player.gold += item.value;
                game.items = game.items.filter(i => i !== item);
                addMessage(`Picked up ${item.value} gold!`, 'item');
            } else if (game.player.inventory.length >= 9) {
                addMessage('Inventory full!', 'info');
            } else {
                game.player.inventory.push(item);
                game.items = game.items.filter(i => i !== item);
                addMessage(`Picked up ${item.name}!`, 'item');
            }
            render();
        }

        function useItem(index) {
            if (index < 0 || index >= game.player.inventory.length) return;

            const item = game.player.inventory[index];

            if (item.type === 'consumable') {
                const healAmount = Math.min(item.heal, game.player.maxHp - game.player.hp);
                game.player.hp += healAmount;
                addMessage(`Used ${item.name}, healed ${healAmount} HP!`, 'item');
                game.player.inventory.splice(index, 1);
            } else if (item.type === 'weapon') {
                if (game.player.weapon === item) {
                    game.player.weapon = null;
                    addMessage(`Unequipped ${item.name}.`, 'item');
                } else {
                    game.player.weapon = item;
                    addMessage(`Equipped ${item.name}!`, 'item');
                }
            } else if (item.type === 'armor') {
                if (game.player.armor === item) {
                    game.player.armor = null;
                    addMessage(`Unequipped ${item.name}.`, 'item');
                } else {
                    game.player.armor = item;
                    addMessage(`Equipped ${item.name}!`, 'item');
                }
            }

            render();
        }

        function useStairs(direction) {
            const tile = game.map[game.player.y][game.player.x];

            if (direction === 'down' && tile === TILES.STAIRS_DOWN) {
                game.dungeonLevel++;
                addMessage(`Descending to dungeon level ${game.dungeonLevel}...`, 'level');
                generateDungeon();
                render();
            } else if (direction === 'up' && tile === TILES.STAIRS_UP) {
                game.dungeonLevel--;
                addMessage(`Ascending to dungeon level ${game.dungeonLevel}...`, 'level');
                generateDungeon();
                render();
            } else {
                addMessage('No stairs here.', 'info');
            }
        }

        // ============================================
        // ENEMY AI
        // ============================================

        function enemyTurn() {
            for (const enemy of game.enemies) {
                // Only act if visible or close
                const dist = Math.abs(enemy.x - game.player.x) + Math.abs(enemy.y - game.player.y);
                if (dist > 10) continue;

                // Check if adjacent to player (attack)
                if (dist === 1) {
                    const enemyAttack = enemy.attack;
                    const playerDefense = game.player.defense + (game.player.armor ? game.player.armor.defense : 0);
                    const damage = Math.max(1, enemyAttack - playerDefense + Math.floor(Math.random() * 2));

                    game.player.hp -= damage;
                    addMessage(`The ${enemy.name} hits you for ${damage} damage!`, 'combat');

                    if (game.player.hp <= 0) {
                        game.gameOver = true;
                        document.getElementById('death-message').textContent =
                            `You were slain by a ${enemy.name} on dungeon level ${game.dungeonLevel}.`;
                        document.getElementById('game-over-screen').style.display = 'flex';
                    }
                    continue;
                }

                // Move towards player
                const dx = Math.sign(game.player.x - enemy.x);
                const dy = Math.sign(game.player.y - enemy.y);

                // Try horizontal first, then vertical
                let moved = false;
                if (dx !== 0 && canMove(enemy.x + dx, enemy.y)) {
                    enemy.x += dx;
                    moved = true;
                } else if (dy !== 0 && canMove(enemy.x, enemy.y + dy)) {
                    enemy.y += dy;
                    moved = true;
                }

                // If couldn't move preferred direction, try the other
                if (!moved) {
                    if (dy !== 0 && canMove(enemy.x, enemy.y + dy)) {
                        enemy.y += dy;
                    } else if (dx !== 0 && canMove(enemy.x + dx, enemy.y)) {
                        enemy.x += dx;
                    }
                }
            }
        }

        function canMove(x, y) {
            if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
            if (game.map[y][x] === TILES.WALL) return false;
            if (game.enemies.some(e => e.x === x && e.y === y)) return false;
            if (game.player.x === x && game.player.y === y) return false;
            return true;
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        document.addEventListener('keydown', (e) => {
            if (game.gameOver || game.won) return;

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
                case 'g':
                case 'G':
                    e.preventDefault();
                    pickupItem();
                    break;
                case '>':
                case '.':
                    e.preventDefault();
                    useStairs('down');
                    break;
                case '<':
                case ',':
                    e.preventDefault();
                    useStairs('up');
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    e.preventDefault();
                    useItem(parseInt(e.key) - 1);
                    break;
            }
        });

        // ============================================
        // GAME INITIALIZATION
        // ============================================

        function startGame() {
            document.getElementById('title-screen').style.display = 'none';
            game.player = createPlayer();
            game.dungeonLevel = 1;
            game.messages = [];
            game.gameOver = false;
            game.won = false;

            document.getElementById('message-log').innerHTML = '';
            addMessage('Welcome to EmojiHack! Find the Dragon on level 5!', 'info');

            generateDungeon();
            render();
        }

        function restartGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none';
            startGame();
        }

        // Initial render of title screen
        render();
    </script>
</body>
</html>
